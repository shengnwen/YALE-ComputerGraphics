<!DOCTYPE html>

<html>
<head>
  <title>Raytracing</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="custom.css" />
</head>
<body>
  <div id="container">
    <div class='cred'>
        <a href='https://github.com/tmcw/literate-raytracer'>an open source project by tom macwright</a>
    </div>
    <canvas id='c'></canvas>
    <center>
        <button id='play'>play</button>
        <button id='stop'>stop</button>
    </center>
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="index.html">
                index.js
              </a>
            
              
              <a class="source" href="vector.html">
                vector.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Raytracing</h1>
<p><strong>Raytracing</strong> is a relatively simple way to render images of 3D objects.
The core is an elegant idea, that one can simulate the real-world behavior
of photons of light bouncing off of surfaces and colors accumulating from
their paths. It&#39;s not inherently fast, but the simplicity of the core lets
it model interesting things like reflections and depth of field in ways
that mirror natural processes.</p>
<h2>CS 301: Raytracing</h2>
<p>This happens to be a popular subject for education: implementing a raytracer
requires a student to understand vector math, fast code, and even recursion.
The reward is a pretty image - more compelling than the blas√© debug output
that students get from most assignments.</p>
<p>But it&#39;s still hard to learn: explanations are written either in the
language of mathematics or programming, and rarely connect all the dots.
Raytracer implementations tend to extremes: one
<a href="http://fabiensanglard.net/rayTracing_back_of_business_card/">fits on a business card</a>,
another <a href="http://www.povray.org/">supports nearly every potential feature</a>,
and most of the rest are <a href="https://github.com/search?q=raytracer+cs&amp;ref=cmdform">homework assignments</a>,
implemented just enough to run, never enough to have comments and documentation.</p>
<h2>Literate Raytracer</h2>
<p><a href="https://github.com/tmcw/literate-raytracer">Literate raytracer</a> is a
simple implementation of raytracing in Javascript. It&#39;s <a href="http://macwright.org/literate-raytracer/">made to be
read as a narrative</a>, and intends
to <a href="http://macwright.org/literate-raytracer/vector.html">explain vector operations</a> as well.</p>
<h1>Setup</h1>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> c = document.getElementById(<span class="string">'c'</span>),
    width = <span class="number">640</span> * <span class="number">0.5</span>,
    height = <span class="number">480</span> * <span class="number">0.5</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Get a context in order to generate a proper data array. We aren&#39;t going to
use traditional Canvas drawing functions like <code>fillRect</code> - instead this
raytracer will directly compute pixel data and then put it into an image.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>c.width = width;
c.height = height;
c.style.cssText = <span class="string">'width:'</span> + (width * <span class="number">2</span>) + <span class="string">'px;height:'</span> + (height*<span class="number">2</span>) + <span class="string">'px'</span>;
<span class="keyword">var</span> ctx = c.getContext(<span class="string">'2d'</span>),
    data = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, width, height);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h1>The Scene</h1>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> scene = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p><img src="http://farm4.staticflickr.com/3781/10524236814_5a9c43487a_b.jpg" alt=""></p>
<p>We need to define three different kinds of things in 3D space:
a <strong>camera</strong> from which we cast rays into the scene, <strong>objects</strong>
that can be hit by those rays and are drawn into the scene, and
<strong>lights</strong> that change the color of rays, by extension coloring objects.</p>
<p>In this case, we define these objects as simple objects with vectors
defined as <code>{x, y, z}</code> objects.</p>
<h2>The Camera</h2>
<p>Our camera is pretty simple: it&#39;s a point in space, where you can imagine
that the camera &#39;sits&#39;, a <code>fieldOfView</code>, which is the angle from the right
to the left side of its frame, and a <code>vector</code> which determines what
angle it points in.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>scene.camera = {
    point: {
        x: <span class="number">0</span>,
        y: <span class="number">1.8</span>,
        z: <span class="number">10</span>
    },
    fieldOfView: <span class="number">45</span>,
    vector: {
        x: <span class="number">0</span>,
        y: <span class="number">3</span>,
        z: <span class="number">0</span>
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h2>Lights</h2>
<p>Lights are defined only as points in space - surfaces that have lambert
shading will be affected by any visible lights.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>scene.lights = [{
    x: -<span class="number">30</span>,
    y: -<span class="number">10</span>,
    z: <span class="number">20</span>
}];</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2>Objects</h2>
<p>This raytracer handles sphere objects, with any color, position, radius,
and surface properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>scene.objects = [
    {
        type: <span class="string">'sphere'</span>,
        point: {
            x: <span class="number">0</span>,
            y: <span class="number">3.5</span>,
            z: -<span class="number">3</span>
        },
        color: {
            x: <span class="number">155</span>,
            y: <span class="number">200</span>,
            z: <span class="number">155</span>
        },
        specular: <span class="number">0.2</span>,
        lambert: <span class="number">0.7</span>,
        ambient: <span class="number">0.1</span>,
        radius: <span class="number">3</span>
    },
    {
        type: <span class="string">'sphere'</span>,
        point: {
            x: -<span class="number">4</span>,
            y: <span class="number">2</span>,
            z: -<span class="number">1</span>
        },
        color: {
            x: <span class="number">155</span>,
            y: <span class="number">155</span>,
            z: <span class="number">155</span>
        },
        specular: <span class="number">0.1</span>,
        lambert: <span class="number">0.9</span>,
        ambient: <span class="number">0.0</span>,
        radius: <span class="number">0.2</span>
    },
    {
        type: <span class="string">'sphere'</span>,
        point: {
            x: -<span class="number">4</span>,
            y: <span class="number">3</span>,
            z: -<span class="number">1</span>
        },
        color: {
            x: <span class="number">255</span>,
            y: <span class="number">255</span>,
            z: <span class="number">255</span>
        },
        specular: <span class="number">0.2</span>,
        lambert: <span class="number">0.7</span>,
        ambient: <span class="number">0.1</span>,
        radius: <span class="number">0.1</span>
    }
];</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h1>Throwing Rays</h1>
<p>This is one part where we can&#39;t follow nature exactly: technically photons
come out of lights, bounce off of objects, and then some hit the &#39;eye&#39;
and many don&#39;t. Simulating this - sending rays in all directions out of
each light and most not having any real effect - would be too inefficient.</p>
<p>Luckily, the reverse is more efficient and has practically the same result -
instead of rays going &#39;from&#39; lights to the eye, we follow rays from the eye
and see if they end up hitting any features and lights on their travels.</p>
<p>For each pixel in the canvas, there needs to be at least one ray of light
that determines its color by bouncing through the scene.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">(scene)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>first &#39;unpack&#39; the scene to make it easier to reference</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> camera = scene.camera,
        objects = scene.objects,
        lights = scene.lights;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>This process
is a bit odd, because there&#39;s a disconnect between pixels and vectors:
given the left and right, top and bottom rays, the rays we shoot are just
interpolated between them in little increments.</p>
<p>Starting with the height and width of the scene, the camera&#39;s place,
direction, and field of view, we calculate factors that create
<code>width*height</code> vectors for each ray</p>
<p>Start by creating a simple vector pointing in the direction the camera is
pointing - a unit vector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> eyeVector = Vector.unitVector(Vector.subtract(camera.vector, camera.point)),</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>and then we&#39;ll rotate this by combining it with a version that&#39;s turned
90¬∞ right and one that&#39;s turned 90¬∞ up. Since the <a href="http://en.wikipedia.org/wiki/Cross_product">cross product</a>
takes two vectors and creates a third that&#39;s perpendicular to both,
we use a pure &#39;UP&#39; vector to turn the camera right, and that &#39;right&#39;
vector to turn the camera up.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        vpRight = Vector.unitVector(Vector.crossProduct(eyeVector, Vector.UP)),
        vpUp = Vector.unitVector(Vector.crossProduct(vpRight, eyeVector)),</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>The actual ending pixel dimensions of the image aren&#39;t important here -
note that <code>width</code> and <code>height</code> are in pixels, but the numbers we compute
here are just based on the ratio between them, <code>height/width</code>, and the
<code>fieldOfView</code> of the camera.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        fovRadians = Math.PI * (camera.fieldOfView / <span class="number">2</span>) / <span class="number">180</span>,
        heightWidthRatio = height / width,
        halfWidth = Math.tan(fovRadians),
        halfHeight = heightWidthRatio * halfWidth,
        camerawidth = halfWidth * <span class="number">2</span>,
        cameraheight = halfHeight * <span class="number">2</span>,
        pixelWidth = camerawidth / (width - <span class="number">1</span>),
        pixelHeight = cameraheight / (height - <span class="number">1</span>);

    <span class="keyword">var</span> index, color;
    <span class="keyword">var</span> ray = {
        point: camera.point
    };
    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; width; x++) {
        <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; height; y++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>turn the raw pixel <code>x</code> and <code>y</code> values into values from -1 to 1
and use these values to scale the facing-right and facing-up
vectors so that we generate versions of the <code>eyeVector</code> that are
skewed in each necessary direction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> xcomp = Vector.scale(vpRight, (x * pixelWidth) - halfWidth),
                ycomp = Vector.scale(vpUp, (y * pixelHeight) - halfHeight);

            ray.vector = Vector.unitVector(Vector.add3(eyeVector, xcomp, ycomp));</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>use the vector generated to raytrace the scene, returning a color
as a <code>{x, y, z}</code> vector of RGB values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            color = trace(ray, scene, <span class="number">0</span>);
            index = (x * <span class="number">4</span>) + (y * width * <span class="number">4</span>),
            data.data[index + <span class="number">0</span>] = color.x;
            data.data[index + <span class="number">1</span>] = color.y;
            data.data[index + <span class="number">2</span>] = color.z;
            data.data[index + <span class="number">3</span>] = <span class="number">255</span>;
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Now that each ray has returned and populated the <code>data</code> array with
correctly lit colors, fill the canvas with the generated data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ctx.putImageData(data, <span class="number">0</span>, <span class="number">0</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h1>Trace</h1>
<p>Given a ray, shoot it until it hits an object and return that object&#39;s color,
or <code>Vector.WHITE</code> if no object is found. This is the main function that&#39;s
called in order to draw the image, and it recurses into itself if rays
reflect off of objects and acquire more color.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">trace</span><span class="params">(ray, scene, depth)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>This is a recursive method: if we hit something that&#39;s reflective,
then the call to <code>surface()</code> at the bottom will return here and try
to find what the ray reflected into. Since this could easily go
on forever, first check that we haven&#39;t gone more than three bounces
into a reflection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (depth &gt; <span class="number">3</span>) <span class="keyword">return</span>;

    <span class="keyword">var</span> distObject = intersectScene(ray, scene);</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>If we don&#39;t hit anything, fill this pixel with the background color -
in this case, white.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (distObject[<span class="number">0</span>] === <span class="literal">Infinity</span>) {
        <span class="keyword">return</span> Vector.WHITE;
    }

    <span class="keyword">var</span> dist = distObject[<span class="number">0</span>],
        object = distObject[<span class="number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>The <code>pointAtTime</code> is another way of saying the &#39;intersection point&#39;
of this ray into this object. We compute this by simply taking
the direction of the ray and making it as long as the distance
returned by the intersection check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> pointAtTime = Vector.add(ray.point, Vector.scale(ray.vector, dist));

    <span class="keyword">return</span> surface(ray, scene, object, pointAtTime, sphereNormal(object, pointAtTime), depth);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h1>Detecting collisions against all objects</h1>
<p>Given a ray, let&#39;s figure out whether it hits anything, and if so,
what&#39;s the closest thing it hits.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">intersectScene</span><span class="params">(ray, scene)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>The base case is that it hits nothing, and travels for <code>Infinity</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> closest = [<span class="literal">Infinity</span>, <span class="literal">null</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>But for each object, we check whether it has any intersection,
and compare that intersection - is it closer than <code>Infinity</code> at first,
and then is it closer than other objects that have been hit?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; scene.objects.length; i++) {
        <span class="keyword">var</span> object = scene.objects[i],
            dist = sphereIntersection(object, ray);
        <span class="keyword">if</span> (dist !== <span class="literal">undefined</span> &amp;&amp; dist &lt; closest[<span class="number">0</span>]) {
            closest = [dist, object];
        }
    }
    <span class="keyword">return</span> closest;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2>Detecting collisions against a sphere</h2>
<p><img src="graphics/sphereintersection.png" alt=""></p>
<p>Spheres are one of the simplest objects for rays to interact with, since
the geometrical math for finding intersections and reflections with them
is pretty straightforward.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">sphereIntersection</span><span class="params">(sphere, ray)</span> {</span>
    <span class="keyword">var</span> eye_to_center = Vector.subtract(sphere.point, ray.point),</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>picture a triangle with one side going straight from the camera point
to the center of the sphere, another side being the vector.
the final side is a right angle.</p>
<p>This equation first figures out the length of the vector side</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        v = Vector.dotProduct(eye_to_center, ray.vector),</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>then the length of the straight from the camera to the center
of the sphere</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        eoDot = Vector.dotProduct(eye_to_center, eye_to_center),</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>and compute a segment from the right angle of the triangle to a point
on the <code>v</code> line that also intersects the circle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        discriminant = (sphere.radius * sphere.radius) - eoDot + (v * v);</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>If the discriminant is negative, that means that the sphere hasn&#39;t
been hit by the ray</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (discriminant &lt; <span class="number">0</span>) {
        <span class="keyword">return</span>;
    } <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>otherwise, we return the distance from the camera point to the sphere
<code>Math.sqrt(dotProduct(a, a))</code> is the length of a vector, so
<code>v - Math.sqrt(discriminant)</code> means the length of the the vector
just from the camera to the intersection point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">return</span> v - Math.sqrt(discriminant);
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>A normal is, at each point on the surface of a sphere or some other object,
a vector that&#39;s perpendicular to the surface and radiates outward. We need
to know this so that we can calculate the way that a ray reflects off of
a sphere.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">sphereNormal</span><span class="params">(sphere, pos)</span> {</span>
    <span class="keyword">return</span> Vector.unitVector(
        Vector.subtract(pos, sphere.point));
}</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h1>Surface</h1>
<p><img src="http://farm3.staticflickr.com/2851/10524788334_f2e3903b36_b.jpg" alt=""></p>
<p>If <code>trace()</code> determines that a ray intersected with an object, <code>surface</code>
decides what color it acquires from the interaction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">surface</span><span class="params">(ray, scene, object, pointAtTime, normal, depth)</span> {</span>
    <span class="keyword">var</span> b = object.color,
        c = Vector.ZERO,
        lambertAmount = <span class="number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p><strong><a href="http://en.wikipedia.org/wiki/Lambertian_reflectance">Lambert shading</a></strong>
is our pretty shading, which shows gradations from the most lit point on
the object to the least.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (object.lambert) {
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; scene.lights.length; i++) {
            <span class="keyword">var</span> lightPoint = scene.lights[<span class="number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>First: can we see the light? If not, this is a shadowy area
and it gets no light from the lambert shading process.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (!isLightVisible(pointAtTime, scene, lightPoint)) <span class="keyword">continue</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Otherwise, calculate the lambertian reflectance, which
essentially is a &#39;diffuse&#39; lighting system - direct light
is bright, and from there, less direct light is gradually,
beautifully, less light.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> contribution = Vector.dotProduct(Vector.unitVector(
                Vector.subtract(lightPoint, pointAtTime)), normal);</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>sometimes this formula can return negatives, so we check:
we only want positive values for lighting.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (contribution &gt; <span class="number">0</span>) lambertAmount += contribution;
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><strong><a href="https://en.wikipedia.org/wiki/Specular_reflection">Specular</a></strong> is a fancy word for &#39;reflective&#39;: rays that hit objects
with specular surfaces bounce off and acquire the colors of other objects
they bounce into.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (object.specular) {</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>This is basically the same thing as what we did in <code>render()</code>, just
instead of looking from the viewpoint of the camera, we&#39;re looking
from a point on the surface of a shiny object, seeing what it sees
and making that part of a reflection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> reflectedRay = {
            point: pointAtTime,
            vector: Vector.reflectThrough(ray.vector, normal)
        };
        <span class="keyword">var</span> reflectedColor = trace(reflectedRay, scene, ++depth);
        <span class="keyword">if</span> (reflectedColor) {
            c = Vector.add(c, Vector.scale(reflectedColor, object.specular));
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>lambert should never &#39;blow out&#39; the lighting of an object,
even if the ray bounces between a lot of things and hits lights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lambertAmount = Math.min(<span class="number">1</span>, lambertAmount);</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p><strong>Ambient</strong> colors shine bright regardless of whether there&#39;s a light visible -
a circle with a totally ambient blue color will always just be a flat blue
circle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> Vector.add3(c,
        Vector.scale(b, lambertAmount * object.lambert),
        Vector.scale(b, object.ambient));
}</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Check whether a light is visible from some point on the surface of something.
Note that there might be an intersection here, which is tricky - but if it&#39;s
tiny, it&#39;s actually an intersection with the object we&#39;re trying to decide
the surface of. That&#39;s why we check for <code>&gt; -0.005</code> at the end.</p>
<p>This is the part that makes objects cast shadows on each other: from here
we&#39;d check to see if the area in a shadowy spot can &#39;see&#39; a light, and when
this returns <code>false</code>, we make the area shadowy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">isLightVisible</span><span class="params">(pt, scene, light)</span> {</span>
    <span class="keyword">var</span> distObject =  intersectScene({
        point: pt,
        vector: Vector.unitVector(Vector.subtract(pt, light))
    }, scene);
    <span class="keyword">return</span> distObject[<span class="number">0</span>] &gt; -<span class="number">0.005</span>;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Here we do a little fun magic, just for the heck of it. We have three spheres
in the scene - <code>scene.objects[0]</code> is the big one, kind of like &#39;Earth&#39;.</p>
<p>The other two are little, so let&#39;s make them orbit around the big one
and look cool!</p>
<p>The orbits of the two planets. We use some basic trigonetry to do the orbits:
using <code>Math.sin()</code> and <code>Math.cos()</code>, it&#39;s simple to get a
<a href="http://en.wikipedia.org/wiki/Unit_circle">unit circle</a>
for each planet. Here&#39;s <a href="http://macwright.org/2013/03/05/math-for-pictures.html">an article I wrote</a>
for getting to know <code>sin</code> and <code>cos</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> planet1 = <span class="number">0</span>,
    planet2 = <span class="number">0</span>;

<span class="function"><span class="keyword">function</span> <span class="title">tick</span><span class="params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>make one planet spin a little bit faster than the other, just for
effect.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    planet1 += <span class="number">0.1</span>;
    planet2 += <span class="number">0.2</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>set the position of each moon with some trig.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    scene.objects[<span class="number">1</span>].point.x = Math.sin(planet1) * <span class="number">3.5</span>;
    scene.objects[<span class="number">1</span>].point.z = -<span class="number">3</span> + (Math.cos(planet1) * <span class="number">3.5</span>);

    scene.objects[<span class="number">2</span>].point.x = Math.sin(planet2) * <span class="number">4</span>;
    scene.objects[<span class="number">2</span>].point.z = -<span class="number">3</span> + (Math.cos(planet2) * <span class="number">4</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>finally, render the scene!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    render(scene);</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>and as soon as we&#39;re finished, render it again and move the planets
again</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (playing) setTimeout(tick, <span class="number">10</span>);
}

<span class="keyword">var</span> playing = <span class="literal">false</span>;

<span class="function"><span class="keyword">function</span> <span class="title">play</span><span class="params">()</span> {</span>
    playing = <span class="literal">true</span>;
    tick();
}

<span class="function"><span class="keyword">function</span> <span class="title">stop</span><span class="params">()</span> {</span>
    playing = <span class="literal">false</span>;
}

render(scene);</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Then let the user control a cute playing animation!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>document.getElementById(<span class="string">'play'</span>).onclick = play;
document.getElementById(<span class="string">'stop'</span>).onclick = stop;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
  <script src='vector.js'></script>
  <script src='index.js'></script>
  <script type="text/javascript">
  var _gauges = _gauges || [];
  (function() {
    var t   = document.createElement('script');
    t.type  = 'text/javascript';
    t.async = true;
    t.id    = 'gauges-tracker';
    t.setAttribute('data-site-id', '4e36eb1ef5a1f53d6f000001');
    t.src = '//secure.gaug.es/track.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(t, s);
  })();
</script>
</body>
</html>
